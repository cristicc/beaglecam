= beaglecam
Cristian Ciocaltea <cristian.ciocaltea@gmail.com>
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]
:example-caption!:
:table-caption!:
:prewrap!:
:imagesdir: docs/img
:toc:
:toc-placement!:
:sectnums:
:sectanchors:
:sectlinks:
:PROJECT_NAME: beaglecam
:PROJECT_URL: https://github.com/cristicc/{PROJECT_NAME}
:PROJECT_DIR: ${HOME}/{PROJECT_NAME}
:OUTPUT_DIR: {PROJECT_DIR}/output
:DEV_OUTPUT_DIR: {OUTPUT_DIR}/dev

toc::[]

IMPORTANT: This is currently a work in progress..

== Intro

This is an experimental embedded Linux OS and application for BeagleBone Black
 <<RefBeagleBoneBlack>> to capture video frames from a OV7670 VGA Camera Module
 <<RefOV7670CamModule>> and display them via a 4.3" LCD Display Cape <<BBDisplayCape>>.

The main purpose of this project is to continue and, if possible, to improve the
work done in the context of Bootlin's excellent _Embedded Linux boot time optimization
training_ <<RefBootlinTrainingBootTime>>, which I strongly recommend to anyone looking
for solutions to optimize the boot time of Linux-based operating systems.

The boot duration is measured using an Arduino Nano 33 BLE board <<RefArduinoNano33BLE>>,
from BeagleBone Black's system reset until the first video frame is captured from
the camera and presented on the LCD.

The Arduino board starts a timer as soon as the reset signal is received from the
BeagleBone board (via a GPIO pin). The timer is stopped when a second GPIO signal
is received, which marks the completion of the first video frame capture.
The elapsed time is displayed in real time on a Midas 16x2 alphanumeric LCD <<RefMidasLCD>>
controlled by Arduino via I2C.


== Hardware setup

=== Main components

ifdef::env-github[]
image::hardware-overview.svg[]
endif::[]

ifndef::env-github[]
[ditaa]
----
             +----------------------------------------+
             |           BeagleBone Black             |
             |                                        |   +----------------+
             |    +----------------+                  |   |    16x2 LCD    |
     +----------->|    GPIO PIN    +-------------+    |   |     Display    |
     |       |    |     Headers    +-------+     |    |   +----------------+
     |       |    +----------------+       |     |    |               ^
     |       |      ^     ^                |     +-------------+      |
 I/O |       |  I/O |     | I/O        I2C |          |    I/O |      | I2C
     v       |      v     v                v          |        v      v
 /--------\  | +------+------+     /---------------\  |   /----------------\
 | OV7670 |  | |      |      |     |               |  |   |                |
 |  Cam   |  | | PRU  | PRU  |<--->|   Linux       |  |   |  Arduino Nano  |
 | Module |  | |  0   |  1   | IPC |     Kernel    |  |   |     33 BLE     |
 |     {d}|  | |      |      |     |               |  |   |                |
 \---+----/  | +------+------+     \---------------/  |   \----------------/
             |                                        |
             +----------------------------------------+
----
endif::[]


=== Breadboard prototype

image::beaglecam-prototype.svg[]


=== BeagleBone Black

[NOTE]
Please refer to the BeagleBone Black product page <<RefBeagleBoneBlack>>.

==== PRU Pins

There are 16 input pins (and 16 output) pins per PRU core, but not all of these
are accessible on the BeagleBone Black. Additionally, some of them are already
in use by the LCD cape, hence we can only access less than half of the inputs
(see the table below for more details about the available pins).

[NOTE]
For more details about the Programmable Real-time Unit Sub System, please see <<RefAm33xxPrussv2>>.

.BeagleBone PRU input pins for capturing camera frames via `D0-D7`, `PCLK`, `HREF` and `VSYNC`
|===
| PRU# | R31 bit | BB Header | BB Pin Name | ZCZ BallName  | Pinmux Mode | Cam Pin Name | Comments

| 0    |  0      | P9_31     | SPI1_SCLK   | mcasp0_aclkx  | Mode_6      | D0    |
| 0    |  1      | P9_29     | SPI1_D0     | mcasp0_fsx    | Mode_6      | D1    |
| 0    |  2      | P9_30     | SPI1_D1     | mcasp0_axr0   | Mode_6      | D2    |
| 0    |  3      | P9_28     | SPI1_CS0    | mcasp0_ahclkr | Mode_6      |       | See <<pru-pins-conflict>>
| 0    |  4      | P9_42     | GPIO3_18    | mcasp0_aclkr  | Mode_6      | D4    | See <<pru-pins-note1>>
| 0    |  5      | P9_27     | GPIO3_19    | mcasp0_fsr    | Mode_6      | D5    |
| 0    |  6      | P9_41     | GPIO3_20    | mcasp0_axr1   | Mode_6      | D6    | See <<pru-pins-note2>>
| 0    |  7      | P9_25     | GPIO3_21    | mcasp0_ahclkx | Mode_6      | D7    |
| 0    | 14      | P8_16     | GPIO1_14    | gpmc_ad14     | Mode_6      | D3    |
| 0    | 15      | P8_15     | GPIO1_15    | gpmc_ad15     | Mode_6      | PCLK  |
| 0    | 16      | P9_24     | UART1_TXD   | uart1_txd     | Mode_6      | HREF  |
| 1    | 12      | P8_21     | GPIO1_30    | gpmc_csn1     | Mode_6      | VSYNC |
| 1    | 13      | P8_20     | GPIO1_31    | gpmc_csn2     | Mode_6      |       | Not used
| 1    | 16      | P9_26     | UART1_RXD   | uart1_rxd     | Mode_6      |       | Not used
|===

[#pru-pins-notes]
[NOTE]
====
[[pru-pins-note1,Note1]]
Note 1::
Bit 4 of the PRU0 registers 30 & 31 (`GPIO3_18`) is routed to P9_42 (`GPIO0_7`) pin.
It is necessary to set GPIO0_7 to *input* mode via pinmuxing.

[[pru-pins-note2,Note2]]
Note 2::
Bit 6 of the PRU0 registers 30 & 31 (`GPIO3_20`) is routed to P9_41 (`GPIO0_20` / `CLKOUT2`).
It is necessary to set `GPIO0_20` to *input* mode via pinmuxing.

[[pru-pins-conflict,Conflict]]
Conflict::
Bit 3 of the PRU0 registers is cannot be used since the corresponding pin P9_28 (`SPI1_CS0`)
is already used by the LCD cape in `Mode_4` (`eCAP2_in_PWM2_out`).
====


=== Camera module

.BeagleBone pins for controlling camera via `XCLK`, `SIO_C` and `SIO_D`
|===
| BB Header | BB Pin Name | ZCZ BallName  | Pinmux Mode | Pinmux Function | Cam Pin Name

| P8_07     | TIMER4      | gpmc_advn_ale | Mode_2      | timer4          | XCLK
| P9_21     | UART2_TXD   | spi0_d0       | Mode_2      | I2C2_SCL        | SIO_C
| P9_22     | UART2_RXD   | spi0_sclk     | Mode_2      | I2C2_SDA        | SIO_D
|===

.VGA Frame Timing
====
ifdef::env-github[]
image::cam-module-signals.svg[]
endif::[]

ifndef::env-github[]
[wavedrom]
----
{ signal: [
  { name: "PCLK",   wave: "p....|..|......" },
  { name: "HREF",   wave: "0..1.|.0|1..0.." },
  { name: "VSYNC",  wave: "010..|..|....10" },
  { name: "D[7:0]", wave: "x..45|6x|=..x..", data: ["B0", "", "Bn", "LastRow"] }
]}
----
endif::[]
====


== Build process

Please follow the instructions below to setup your build environment and
generate the project binaries: rootfs/initramfs, Linux kernel, U-Boot.

=== Host system setup

The project building process has been tested on an Ubuntu 20.04 chroot environment,
using `schroot`, but it should work on any recent Debian based distribution.

Please run the commands below to install all the packages the build environment
relies on:

[source,sh]
----
# Required for generating uImage compatible binaries
$ sudo apt install u-boot-tools

# Required for creating/flashing SD card images (dialog, mkdosfs, mcopy)
$ sudo apt install dialog dosfstools mtools

# Required for building the x86 TI's PRU Code Generation Tools (CGT)
$ sudo apt install libc6-i386 lib32stdc++6 lib32z1

# Possibly required for building the Linux kernel
$ sudo apt install kmod libgmp-dev libmpfr-dev libmpc-dev libssl-dev lzop

# Common (usually pre-installed) utilities
$ sudo apt install cpio gawk gettext git openssh-client patch perl python rsync tar unzip wget

# Other (indirect) dependencies
$ sudo apt install bc bison flex genisoimage gperf help2man libncurses-dev libtool-bin texinfo
----

[IMPORTANT]
For other distros (e.g. RPM based), the commands above must be adapted according
to the specific package manager and actual package names.


=== Get project sources

Let's assume the project location throughout the document will be `{PROJECT_DIR}`.
The simplest approach to get the sources is to clone the upstream repository:

[source,sh,subs="attributes+"]
$ cd ${HOME}
$ git clone {PROJECT_URL}.git

Alternatively, you may directly download the source archive:

[source,sh,subs="attributes+"]
$ wget {PROJECT_URL}/archive/refs/heads/main.zip
$ unzip main.zip
$ mv {PROJECT_NAME}-main {PROJECT_DIR}
$ rm main.zip

[TIP]
====
If `wget` utility is not available and you don't want to install and use it,
you could try to download the source archive with `curl`:

[source,sh,subs="attributes+"]
$ curl -O {PROJECT_URL}/archive/refs/heads/main.zip
====


=== Configure the build

The project uses a `make` infrastructure inspired from _Buildroot_ and is able
to build most of the components (i.e. Linux kernel, U-Boot) directly.

For building more complex components like the _toolchain_ and the _rootfs_/_initramfs_,
the build platform is using _Buildroot_ internally, but the whole process is automatic
(e.g. downloading/configuring/building external dependencies, including _buildroot_)
and no manual interventions are required.

[source,sh,subs="attributes+"]
----
$ cd {PROJECT_DIR}
$ make help
Options:
  V=0|1                  0 => quiet build (default), 1 => verbose build
  O=DIR                  Create all output artifacts in DIR.

Main targets:
  prepare                Create build output directories and Makefile wrapper.
  all                    Build project.
  clean                  Delete all files created by build.
  distclean              Delete all non-source files (including downloads).
  reconfigure            Rebuild all project components from the configure step.
  rebuild                Rebuild all project components.

[...]
----

The default build configuration options are stored in `prj.config`. It is
recommended to keep them unchanged for the first build, to be able to validate
the build environment.

Later you may want to adjust some of the following settings:

[source,makefile]
PRJ_LINUX_KERNEL_VERSION = a.b.c
PRJ_UBOOT_VERSION = yyyy.mm
PRJ_BUILDROOT_VERSION = yyyy.mm[.bb]

Currently the project allows choosing between two build profiles: `prod` and
`dev`. The former is implicitly used if the `PRJ_PROFILE` variable is not set
by the user via the command line or the environment.

By default, the build artifacts will be stored in `{OUTPUT_DIR}`, but this can
be changed via the `O=DIR` option, for an out-of-tree build.

Now run the following command to initialize the chosen output directory for the
`dev` profile we are going to use. Additionally we also provide a custom
location for the downloaded source archives to be able to share it between the
two profiles, otherwise every profile will use its own download folder and, as
a consequence, the source packages will be downloaded twice. Also note we call
the `prepare` target manually to make sure `make` will not trigger `all` which
would start the build process. However this is not mandatory since `prepare` is
implicitly invoked before building any project component.

[source,sh,subs="attributes+"]
----
$ make O={DEV_OUTPUT_DIR} PRJ_PROFILE=dev DOWNLOAD_DIR={DEV_OUTPUT_DIR}/../downloads/ prepare
  GEN     {DEV_OUTPUT_DIR}/Makefile

$ ls -1a {DEV_OUTPUT_DIR}
binaries
build
host
Makefile
.stamp_prepared
----

The `binaries` folder will contain final images (e.g. kernel, u-boot, rootfs),
the `build` folder is used for temporary build artifacts and the `host` folder
will contain the binaries for the host components (e.g. `genimage` tool).
`.stamp_prepared` is a timestamp file used internally by the build platform to
avoid redoing the preparation step once completed.

[TIP]
There is also a `Makefile` wrapper generated in the custom output folder having
the purpose of simplifying the `make` usage for out-of-tree builds, i.e. simply
`cd` to the custom output directory and run `make` *without* passing any of the
initial arguments.


=== Start the build

To build all the project components, just issue the `make` command in the project
root directory, assuming you are not using the out-of-tree option, otherwise run
the command in the custom output directory.

[source,sh,subs="attributes+"]
----
$ cd {DEV_OUTPUT_DIR}
$ make
[...]
=== toolchain  Installing to binaries directory
[...]
=== linux 5.11.11 Installing to binaries directory
[...]
=== rootfs  Installing to binaries directory
[...]
=== uboot 2021.04 Installing to binaries directory
[...]
=== prj  Rebuilding kernel with initramfs
[...]
=== prj  Installing to binaries directory
=== prj  Stripping binaries
=== prj  Generating bootable SD card image
----

The generated images are stored in the `binaries` folder:

[source,sh]
$ ls -1 binaries/
am335x-boneblack-lcd43.dtb
boot.vfat
MLO
rootfs.cpio
sd-card.img
u-boot.img
uEnv-falcon.txt
uEnv.txt
uImage
zImage

[IMPORTANT]
`uImage` is the kernel image to be used for <<enable-falcon,falcon boot>>.
For regular boot, the `zImage` format will be used instead.


== Deployment and testing

=== Prepare a bootable uSD card

Insert the micro SD card in a USB card reader attached to the host system and
run the following command, assuming the current working directory is still
the project output directory:

[source,sh,subs="attributes+"]
{PROJECT_DIR}/tools/prepare-sd-card.sh binaries/sd-card.img

You should see a dialog box displaying the list of all removable USB drives
currently accessible from the host system:

image::usb-drive-select.png[]

Select the correct drive and press `OK` to start flashing the device using
the storage disk image file (`sd-card.img`) generated by the build process:

[script,txt]
----
Please wait while writing 'binaries/sd-card.img' to '/dev/sda'..
50331648 bytes (50 MB, 48 MiB) copied, 2 s, 24.5 MB/s
12+1 records in
12+1 records out
53477376 bytes (53 MB, 51 MiB) copied, 2.21715 s, 24.1 MB/s
Done.
----


=== Boot BeagleBone SBC

Insert the uSD card into BeagleBone SBC and connect the board to the host system
using a compatible USB-to-TTL Serial Cable.

Assuming the serial adapter on the host is accessible via `/dev/ttyUSB0`, you
may use the `screen` utility to monitor the serial console:

[source,sh]
----
$ screen /dev/ttyUSB0 115200

U-Boot SPL 2021.01 (May 24 2021 - 19:26:29 +0000)
Trying to boot from MMC1
[...]

U-Boot 2021.01 (May 24 2021 - 19:26:29 +0000)

CPU  : AM335X-GP rev 2.1
Model: TI AM335x BeagleBone Black
DRAM:  512 MiB
[...]

Starting kernel ...

[    0.000000] Booting Linux on physical CPU 0x0
[    0.000000] Linux version 5.11.11 (cristi@ubuntuws) (arm-linux-gcc.br_real (Buildroot 2020.08-14-ge5a2a90) 9.3.0, GNU ld (GNU Binutils) 2.33.1) #7 SMP Sat May 29 21:05:26 UTC 2021
[    0.000000] CPU: ARMv7 Processor [413fc082] revision 2 (ARMv7), cr=10c5387d
[...]
Starting syslogd: OK
Starting klogd: OK
Running sysctl: OK
Starting dropbear sshd: OK
Starting network: OK

beaglecam login: root

╔══╗         ╔╗   ╔═══╗     ╔═══╦═══╗
║╔╗║         ║║   ║╔═╗║     ║╔═╗║╔═╗║
║╚╝╚╦══╦══╦══╣║╔══╣║ ╚╬══╦╗╔╣║ ║║╚══╗
║╔═╗║║═╣╔╗║╔╗║║║║═╣║ ╔╣╔╗║╚╝║║ ║╠══╗║
║╚═╝║║═╣╔╗║╚╝║╚╣║═╣╚═╝║╔╗║║║║╚═╝║╚═╝║
╚═══╩══╩╝╚╩═╗╠═╩══╩═══╩╝╚╩╩╩╩═══╩═══╝
          ╔═╝║   Version 0.1 (dev)
          ╚══╝
root@beaglecam:~#
----

[TIP]
====
To make sure BeagleBone is booting from the uSD card, stop at the U-Boot prompt
(keep pressing the SPACE key while resetting the board) and run the following
commands to erase the partition table of the on-board (e)MMC storage:

[script,sh]
----
=> mmc list
OMAP SD/MMC: 0 (SD)
OMAP SD/MMC: 1

=> mmc dev 1
switch to partitions #0, OK
mmc1(part 0) is current device

=> mmc erase 0 0x400
MMC erase: dev # 1, block # 0, count 1024 ... 1024 blocks erased: OK
----
====


[#enable-falcon]
=== Enable U-Boot Falcon mode

This operation mode allows U-Boot MLO (SPL) to skip loading `u-boot.img` and
instead load and start the Linux kernel directly.

Stop at the U-Boot prompt and run the following commands:

[script,sh]
----
=> load mmc 0:1 ${loadaddr} uEnv-falcon.txt
427 bytes read in 2 ms (208 KiB/s)

=> env import -t ${loadaddr} ${filesize}

=> run enable_falcon
2726600 bytes read in 178 ms (14.6 MiB/s)
66560 bytes read in 6 ms (10.6 MiB/s)
## Booting kernel from Legacy Image at 82000000 ...
   Image Name:   Linux-5.11.11
   Created:      2021-05-24  20:20:53 UTC
   Image Type:   ARM Linux Kernel Image (uncompressed)
   Data Size:    2726536 Bytes = 2.6 MiB
   Load Address: 80008000
   Entry Point:  80008000
   Verifying Checksum ... OK
## Flattened Device Tree blob at 88000000
   Booting using the fdt blob at 0x88000000
   Loading Kernel Image
   Loading Device Tree to 8ffec000, end 8ffff3ff ... OK
subcommand not supported
subcommand not supported
   Loading Device Tree to 8ffd5000, end 8ffeb3ff ... OK
Argument image is now in RAM: 0x8ffd5000
WARN: FDT size > CMD_SPL_WRITE_SIZE
69632 bytes written in 61 ms (1.1 MiB/s)
Saving Environment to FAT... OK
----

Now restart the board, either from the RESET button or from U-Boot console:

[script,sh]
----
=> reset
resetting ...

U-Boot SPL 2021.01 (May 24 2021 - 19:26:29 +0000)
Trying to boot from MMC1
spl: falcon_args_file not set in environment, falling back to default
Starting ffmpeg
[...]
First frame decoded!
----


== Further development

* Implement a v4l2 Linux kernel driver for the camera module
* Add support for other boards (e.g. RaspberryPi, BeagleV)


[bibliography]
== References

* [[[RefBeagleBoneBlack,1]]] BeagleBone Black product page: https://beagleboard.org/black
* [[[RefOV7670CamModule,2]]] OV7670 Camera Module: https://www.optimusdigital.ro/en/optical-sensors/624-modul-camera-ov7670.html
* [[[BBDisplayCape,3]]] BeagleBone 4.3" LCD Display Cape: https://www.element14.com/community/docs/DOC-81966
* [[[RefBootlinTrainingBootTime,4]]] Bootlin's Embedded Linux boot time optimization training: https://bootlin.com/training/boot-time/
* [[[RefArduinoNano33BLE,5]]] Arduino Nano 33 BLE: https://store.arduino.cc/arduino-nano-33-ble
* [[[RefMidasLCD,6]]] Midas 16x2 I2C Alphanumeric LCD: https://uk.farnell.com/midas/mccog21605b6w-fptlwi/lcd-cog-16x2-i2c-fstn-blk-on-white/dp/2218942
* [[[RefAm33xxPrussv2,7]]] Ti AM33XX PRUSSv2: https://elinux.org/Ti_AM33XX_PRUSSv2
