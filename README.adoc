= beaglecam
Cristian Ciocaltea <cristian.ciocaltea@gmail.com>
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]
:example-caption!:
:table-caption!:
:prewrap!:
:imagesdir: docs/img
:toc:
:toc-placement!:
:sectnums:
:sectanchors:
:sectlinks:
:PROJECT_NAME: beaglecam
:PROJECT_URL: https://github.com/cristicc/{PROJECT_NAME}
:PROJECT_DIR: ${HOME}/{PROJECT_NAME}
:OUTPUT_DIR: {PROJECT_DIR}/output
:CUSTOM_OUTPUT_DIR: /path/to/custom/output/dir

toc::[]

IMPORTANT: This is currently a work in progress..

== Intro

This is an experimental embedded Linux OS and application for BeagleBone Black
 <<RefBeagleBoneBlack>> to capture video frames from a OV7670 VGA Camera Module
 <<RefOV7670CamModule>> and display them via a 4.3" LCD Display Cape <<BBDisplayCape>>.

The main purpose of this project is to continue and, if possible, to improve the
work done in the context of Bootlin's excelent _Embedded Linux boot time optimization
training_ <<RefBootlinTrainingBootTime>>, which I strongly recommend to anyone looking
for solutions to optimize the boot time of Linux-based operating systems.

The boot duration is measured using an Arduino Nano 33 BLE board <<RefArduinoNano33BLE>>,
from BeagleBone Black's system reset until the first video frame is captured from
the camera and presented on the LCD.

The Arduino board starts a timer as soon as the reset signal is received from the
BeagleBone board (via a GPIO pin). The timer is stopped when a second GPIO signal
is received, which marks the completion of the first video frame capture.
The elapsed time is displayed in real time on a Midas 16x2 alphanumeric LCD <<RefMidasLCD>>
controlled by Arduino via I2C.


== Hardware setup

=== Main components

ifdef::env-github[]
image::hardware-overview.svg[]
endif::[]

ifndef::env-github[]
[ditaa]
----
             +----------------------------------------+
             |           BeagleBone Black             |
             |                                        |   +----------------+
             |    +----------------+                  |   |    16x2 LCD    |
     +----------->|    GPIO PIN    +-------------+    |   |     Display    |
     |       |    |     Headers    +-------+     |    |   +----------------+
     |       |    +----------------+       |     |    |               ^
     |       |      ^     ^                |     +-------------+      |
 I/O |       |  I/O |     | I/O        I2C |          |    I/O |      | I2C
     v       |      v     v                v          |        v      v
 /--------\  | +------+------+     /---------------\  |   /----------------\
 | OV7670 |  | |      |      |     |               |  |   |                |
 |  Cam   |  | | PRU  | PRU  |<--->|   Linux       |  |   |  Arduino Nano  |
 | Module |  | |  0   |  1   | IPC |     Kernel    |  |   |     33 BLE     |
 |     {d}|  | |      |      |     |               |  |   |                |
 \---+----/  | +------+------+     \---------------/  |   \----------------/
             |                                        |
             +----------------------------------------+
----
endif::[]

=== Breadboard prototype

image::beaglecam-prototype.svg[]


=== BeagleBone Black

[NOTE]
Please refer to the BeagleBone Black product page <<RefBeagleBoneBlack>>.

==== PRU Pins

There are 16 input pins (and 16 output) pins per PRU core, but not all of these
are accessible on the BeagleBone Black. Additionally, some of them are already
in use by the LCD cape, hence we can only access less than half of the inputs
(see the table bellow for more details about the available pins).

[NOTE]
For more details about the Programmable Real-time Unit Sub System, please see <<RefAm33xxPrussv2>>.

.BeagleBone PRU input pins for capturing camera frames via D0-D7, PCLK, HREF and VSYNC
|===
| PRU# | R31 bit | BB Header | BB Pin Name | ZCZ BallName  | Pinmux Mode | Cam Pin Name | Comments

| 0    |  0      | P9_31     | SPI1_SCLK   | mcasp0_aclkx  | Mode_6      | D0    |
| 0    |  1      | P9_29     | SPI1_D0     | mcasp0_fsx    | Mode_6      | D1    |
| 0    |  2      | P9_30     | SPI1_D1     | mcasp0_axr0   | Mode_6      | D2    |
| 0    |  3      | P9_28     | SPI1_CS0    | mcasp0_ahclkr | Mode_6      |       | See Conflict1
| 0    |  4      | P9_42     | GPIO3_18    | mcasp0_aclkr  | Mode_6      | D4    | See Note1
| 0    |  5      | P9_27     | GPIO3_19    | mcasp0_fsr    | Mode_6      | D5    |
| 0    |  6      | P9_41     | GPIO3_20    | mcasp0_axr1   | Mode_6      | D6    | See Note2
| 0    |  7      | P9_25     | GPIO3_21    | mcasp0_ahclkx | Mode_6      | D7    |
| 0    | 14      | P8_16     | GPIO1_14    | gpmc_ad14     | Mode_6      | D3    |
| 0    | 15      | P8_15     | GPIO1_15    | gpmc_ad15     | Mode_6      | PCLK  |
| 0    | 16      | P9_24     | UART1_TXD   | uart1_txd     | Mode_6      | HREF  |
| 1    | 12      | P8_21     | GPIO1_30    | gpmc_csn1     | Mode_6      | VSYNC |
| 1    | 13      | P8_20     | GPIO1_31    | gpmc_csn2     | Mode_6      |       | Not used
| 1    | 16      | P9_26     | UART1_RXD   | uart1_rxd     | Mode_6      |       | Not used
|===

[NOTE]
====
Note1::
The PRU0 Registers{30,31} Bit 4 (GPIO3_18) is routed to P9_42-GPIO0_7 pin.  You MUST set GPIO0_7 to input mode in pinmuxing.
Both of these signals connect to pin 42 of P11. Resistors are installed that allow for the GPIO3_18
connection to be removed by removing R202. The intent is to allow the SW to use either of these
signals, on pin 42. SW should set the unused pin in input mode when using the other pin. This
allowed us to get an extra signal out to the expansion header.

Note2::
The PRU0 Registers{30,31} Bit 6 (GPIO3_20) is routed to P9_41-GPIO0_20(CLKOUT2). You must set GPIO0_20 to input mode in pinmuxing.
Both of these signals connect to pin 41 of P11. Resistors are installed that allow for the GPIO3_20
connection to be removed by removing R221. The intent is to allow the SW to use either of these
signals, one or the other, on pin 41. SW should set the unused pin in input mode when using the
other pin. This allowed us to get an extra signal out to the expansion header.

Conflict1::
pr1_pru0_pru_r31_3:
AM33XX_PADCONF(AM335X_PIN_MCASP0_AHCLKR, 0x0, MUX_MODE4) /* mcasp0_ahclkr.eCAP2_in_PWM2_out */
====

=== Camera module

.BeagleBone pins for controlling camera via XCLK, SIO_C and SIO_D
|===
| BB Header | BB Pin Name | ZCZ BallName  | Pinmux Mode | Pinmux Function | Cam Pin Name

| P8_07     | TIMER4      | gpmc_advn_ale | Mode_2      | timer4          | XCLK
| P9_21     | UART2_TXD   | spi0_d0       | Mode_2      | I2C2_SCL        | SIO_C
| P9_22     | UART2_RXD   | spi0_sclk     | Mode_2      | I2C2_SDA        | SIO_D
|===

.VGA Frame Timing
====
ifdef::env-github[]
image::cam-module-signals.svg[]
endif::[]

ifndef::env-github[]
[wavedrom]
----
{ signal: [
  { name: "PCLK",   wave: "p....|..|......" },
  { name: "HREF",   wave: "0..1.|.0|1..0.." },
  { name: "VSYNC",  wave: "010..|..|....10" },
  { name: "D[7:0]", wave: "x..45|6x|=..x..", data: ["B0", "", "Bn", "LastRow"] }
]}
----
endif::[]
====


== Build process

Please follow the instructions bellow to setup your build environment and
generate the project binaries: rootfs/initramfs, Linux kernel, U-Boot.

=== Host setup

The project building process has been tested on an Ubuntu 20.04 chroot, but it
should work on any recent enough Debian based distro.

For Debian based distros, there are a few packages that must be installed:

[source,sh]
----
# Required for building the x86 TI's PRU Code Generation Tools (CGT)
$ sudo apt install libc6-i386 lib32stdc++6 lib32z1

# Required for generating uImage compatible binaries
$ sudo apt install u-boot-tools

# Required for managing SD card image: mkdosfs, mcopy, dialog
$ sudo apt install dosfstools mtools dialog

# Required for compressing the Linux kernel using LZO
$ sudo apt install lzop
----

[IMPORTANT]
For other distros (e.g. RPM based), the commands above must be adapted to match
the package manager and actual package names.

=== Get project sources

Let's assume the project location throughout the document will be `{PROJECT_DIR}`.
The simplest approach to get the sources is to clone the upstream repository:

[source,sh,subs="attributes+"]
$ cd ${HOME}
$ git clone {PROJECT_URL}.git

Alternatively, you may directly download the source archive:

[source,sh,subs="attributes+"]
$ wget {PROJECT_URL}/archive/refs/heads/main.zip
$ unzip main.zip
$ mv {PROJECT_NAME}-main {PROJECT_DIR}
$ rm main.zip

[TIP]
====
If `wget` utility is not available and you don't want to install and use it,
you could try to download the source archive with `curl`:

[source,sh,subs="attributes+"]
$ curl -O {PROJECT_URL}/archive/refs/heads/main.zip
====

=== Configure the build

The project uses a `make` infrastructure inspired from _Buildroot_ and is able
to build most of the components (i.e. Linux kernel, U-Boot) directly.

For building more complex components like the _toolchain_ and the _rootfs_/_initramfs_,
the build platform is using _Buildroot_ internally, but the whole process is automatic
(e.g. downloading/configuring/building external dependencies, including _buildroot_)
and no manual interventions are required.

[source,sh,subs="attributes+"]
----
$ cd {PROJECT_DIR}
$ make help
Options:
  V=0|1                  0 => quiet build (default), 1 => verbose build
  O=DIR                  Create all output artifacts in DIR.

Main targets:
  prepare                Create build output directories and Makefile wrapper.
  all                    Build project.
  clean                  Delete all files created by build.
  distclean              Delete all non-source files (including downloads).
  reconfigure            Rebuild all project components from the configure step.
  rebuild                Rebuild all project components.

Generic package build targets:
  GPKG                   Build GPKG and all its dependencies.
  GPKG-extract           Extract GPKG sources.
  GPKG-patch             Apply patches to GPKG.
  GPKG-depends           Build GPKG dependencies.
  GPKG-configure         Build GPKG up to the configure step.
  GPKG-build             Build GPKG up to the build step.
  GPKG-show-depends      List packages on which GPKG depends.
  GPKG-show-recursive-depends
                         Recursively list packages on which GPKG depends.
  GPKG-show-recursive-rdepends
                         Recursively list packages which have GPKG as a dependency.
  GPKG-dirclean          Remove GPKG build directory.
  GPKG-reconfigure       Restart the build from the configure step.
  GPKG-reconfigure-all   Restart the build from the configure step for all deps.
  GPKG-rebuild           Redo the build step.
  GPKG-rebuild-all       Redo the build step for all dependencies.
  GPKG-reinstall         Redo the install step.

Kconfig package build targets:
  KPKG-menuconfig        Call KPKG menuconfig target.
  KPKG-update-config     Copy KPKG config back to the source config file.
  KPKG-update-defconfig  Copy KPKG defconfig back to the source config file.
  KPKG-savedefconfig     Create KPKG defconfig without updating source config file.
  KPKG-diff-config       Show diff between current config and the source config file.
----

The default build configuration options are stored in `prj.config`. It is
recommended to keep them unchanged for the first build, to be able to validate
the build environment.

Later you may want to adjust some of the following settings:

[source,makefile]
PRJ_LINUX_KERNEL_VERSION = a.b.c
PRJ_UBOOT_VERSION = yyyy.mm
PRJ_BUILDROOT_VERSION = yyyy.mm[.bb]

[IMPORTANT]
====
For falcon boot, ensure the following settings are provided:

[source,makefile]
PRJ_LINUX_IMAGE_NAME = uImage
PRJ_LINUX_KERNEL_UIMAGE_LOADADDR = 80008000

For normal boot, use `PRJ_LINUX_IMAGE_NAME = zImage`.
====

By default, the build artifacts will be stored in `{OUTPUT_DIR}`, but
this can be changed via the `O=DIR` option, for an out-of-tree build:

[source,sh,subs="attributes+"]
$ make O={CUSTOM_OUTPUT_DIR}

It will create the given path and also the following content:

[source,sh,subs="attributes+"]
$ ls -1a {CUSTOM_OUTPUT_DIR}
binaries
build
.config
Makefile

The `binaries` folder will contain final images, the `build` folder is used
for build artifacts and the `.config` file is a copy of the `prj.config` and will
be included by the build platform on every `make` invocation. Thus any later
changes to `prj.config` will be ignored unless `.config` is manually removed or,
better, `make reconfig` has been issued.

[TIP]
There is a `Makefile` wrapper generated in the custom output folder having the
purpose of simplifying the `make` usage for out-of-tree builds, i.e. simply `cd`
to the custom output directory and run `make` without passing the `O=` argument.

=== Start the build

To build all the project components, just issue the `make` command in the project
root directory, assuming you are not using the out-of-tree option, otherwise run
the command in the custom output directory.

[source,sh,subs="attributes+"]
----
$ cd {CUSTOM_OUTPUT_DIR}
$ make
[...]
=== toolchain  Installing to binaries directory
[...]
=== linux 5.11.11 Installing to binaries directory
[...]
=== rootfs  Installing to binaries directory
[...]
=== uboot 2021.04 Installing to binaries directory
[...]
=== prj  Rebuilding kernel with initramfs
[...]
=== prj  Installing to binaries directory
=== prj  Stripping binaries
=== prj  Generating bootable SD card image
----

The generated images are stored in the `binaries` folder:

[source,sh]
$ ls -1 binaries/
boot.vfat
MLO
rootfs.cpio
rootfs.tar
sd-card.img
u-boot.img
uEnv.txt
uImage

[IMPORTANT]
`uImage` is the kernel image to be used for falcon boot. For regular boot, the
build configuration should be changed to generate `zImage` instead. For more
details, see <<Configure the build>> section.


== Deployment and testing

=== Prepare SD card

Insert the micro SD card in a USB card reader attached to the host system and
run the following command, assuming the current working directory is still
the project output directory:

[source,sh,subs="attributes+"]
{PROJECT_DIR}/tools/prepare-sd-card.sh binaries/sd-card.img

You should see a dialog box displaying the list of all removable USB drives
currently accessible from the host system:

image::usb-drive-select.png[]

Select the correct drive and press `OK` to start flashing the device using
the storage disk image file (`sd-card.img`) generated by the build process.


=== Boot Beaglebone SBC


== Further development

* Implement a v4l2 Linux kernel driver for the camera module
* Add support for other boards (e.g. RaspberryPi, BeagleV)


[bibliography]
== References

* [[[RefBeagleBoneBlack,1]]] BeagleBone Black product page: https://beagleboard.org/black
* [[[RefOV7670CamModule,2]]] OV7670 Camera Module: https://www.optimusdigital.ro/en/optical-sensors/624-modul-camera-ov7670.html
* [[[BBDisplayCape,3]]] BeagleBone 4.3" LCD Display Cape: https://www.element14.com/community/docs/DOC-81966
* [[[RefBootlinTrainingBootTime,4]]] Bootlin's Embedded Linux boot time optimization training: https://bootlin.com/training/boot-time/
* [[[RefArduinoNano33BLE,5]]] Arduino Nano 33 BLE: https://store.arduino.cc/arduino-nano-33-ble
* [[[RefMidasLCD,6]]] Midas 16x2 I2C Alphanumeric LCD: https://uk.farnell.com/midas/mccog21605b6w-fptlwi/lcd-cog-16x2-i2c-fstn-blk-on-white/dp/2218942
* [[[RefAm33xxPrussv2,7]]] Ti AM33XX PRUSSv2: https://elinux.org/Ti_AM33XX_PRUSSv2
